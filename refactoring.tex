\documentclass[10pt,twocolumn,letterpaper]{article}

\usepackage[scaled]{helvet}
\usepackage[T1]{fontenc}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{epsfig}
\usepackage{tikz} 
\usepackage{graphicx}
\usepackage{stackengine}
\usepackage{times}
\usepackage{url}
\usepackage[backend=bibtex]{biblatex}

%\usepackage[pagebackref=true,breaklinks=true,colorlinks,bookmarks=false,linkcolor=black,citecolor=black]{hyperref}
\usepackage{hyperref}

\def\httilde{\mbox{\tt\raisebox{-.5ex}{\symbol{126}}}}

\newcommand\todo[1]{\textcolor{red}{ToDo: #1}}
\newcommand\note[1]{\textcolor{red}{Note: #1}}

\newcommand\email[1]{\small{\href{mailto:#1}{\color{black}{\nolinkurl{#1}}}}}

% Pages are numbered in submission mode, and unnumbered in camera-ready
\begin{document}

%%%%%%%%% TITLE
\title{Refactoring as epistemic and artistic practice}

\author{Dennis Scheiba\\
\email{dennis.scheiba@rsh-duesseldorf.de}\\
Robert Schumann Hochschule Düsseldorf - Institut für Musik und Medien\\
}
\maketitle

%%%%%%%%% ABSTRACT
\begin{abstract}
\vspace{-1em}
Refactoring is a crucial and daily practice in software development, yet it is difficult to define a precise goal to this exact process.
One could argue refactoring that refactoring is a re-evaluation and modification of existing modularization in the context of what the status quo is and projecting what this status quo could be in the future.

Revisiting the work of oneself or others is not just important in software development but also within the context of art and science.
In this paper we want to explore how the practice of refactoring can be transformed to other domains and inspecting implementations, implication and practices which could be adopt and transformed among each domain.
\end{abstract}

%%%%%%%%% BODY TEXT
\vspace{-1em}

\section{Refactoring and modularization} \label{what}

There is no singleton purpose of refactoring and although its purpose is arguably existing and much important
it is difficult to give a precise definition.
The struggle between intuition, between generalization, simplification and complexity is where refactoring resides.
Attached to this method is always the evaluation of a trade-off, between opening possibilities which at the same time makes other possibilities impossible.

Another goal of refactoring is modularization which allows to separate an existing complex subject into distinctive yet not fully independent sub discretizations which then can be adapted on a per-context basis.
Mathematics, which is often labeled as a \textit{auxillary science}, has the goal to form such universal statements.
This should be motivation enough to stay in this transformation process of re-factoring which allows us to transform the foundations of our believes as this will not solve complexity but allows to inspect complexity within complexity.

Yet we must discuss if modularization actually exists as well as abstraction itself which should be doubted at first as well.

\subsection{Modularization}

Separating the terms software and art is highly doubtful and should not be made easily.
For the sake of simplicity we will nonetheless allow us to work with stereotypes here.

\subsubsection*{In Software}

Somehow there is a common conception of what a \textit{good} written software is and what is not.
This \textit{quality} can be evaluated on multiple categories such as

\begin{itemize}
    \item Bugs
    \item Features
    \item Usability
    \item Catholicity
    \item License
\end{itemize}

of which some categories can be linearly independent or strictly co-relating with each other.
Just remember the quote \begin{quote}
    is this a bug or a feature?
\end{quote}
which is somehow similliar to the quote \begin{quote}
    % harpe kerkeling?
    is this art or rubbish
\end{quote}
which probably finds it motivation by the infamous \textit{Fettecke} by Joseph Beuys.

Projects like \textit{SonarQube} gives us the promise to quantify the quality of such source code can be measured based on certain criteria.
Yet we ask ourselves why such a Software is limited to the domain of programming source code and not beyond other domains which allow for re-transformation of their field, which means refactoring.
[note that there are neural networks which evaluate aesthetic characteristics but not on a hard rule set?]

Modularization in software allows an isolation, encapsulation and restructuring of a given complex and over the years certain patterns emerged in which software is build.
One of the most crucial things of modularization is a common API (Application Programming Interface) which allows the communication between.
Yet the construction of such an API is tied to the concepts of the domain itself but also allows to go beyond it.
Do we talk to everyone who can talk (duck typing) or do we only talk to a certain kind of entities (static typing)?
Common techniques are called design principles, paradigms or techniques, yet rarely they reflect on their ideological implications.

By reaching out we allow ourselves to re-contextualize the domain in a new context which offers, speaking in neo-liberalism terms, a win-win opportunity for both parties.
This allows for justification among society and ourselves what we are doing, providing a leap forward and gaining a new perspective to our field of interest and also to test our assumptions in a new domain.
% use turing completeness as a foundation here?

Although we yet omitted one crucial statement which is the foundation upon all modularization and transformation, the common ground of turing completeness which.
Yet it is false to assume that this allows us to do anything at all time - we do not use Power Point as a ? [note that powerpoint is indeed turing complete] and don't use this for that simply because the intentions of each tool are aimed at a different purpose  - while they all rely on a coordination of voltages in a circuit based upon its environment, art has the same universal language of communication as it tries to evoke a resonance within a biological circuit with the means of sensorial evaluation.

This means that all programs which are Turing complete are interchangeable but in order to build complex programs we need to tame the possibilities.
By deciding what is and what is not possible within our program we allow the program to exist [what about kernels?], albeit this reduction of possibilities can be achieved on different levels of operation.

This is often seen in the domain of arts as well as the segregation of fine arts, music, media art and science is still often separated at institutes.

Also the human as a social being can not escape exposure to its culture, therefore all creations could be seen as reactions to the input we have received.
The most obvious way of this mechanic is quotation or sampling which allows for a transformation and re-contextualization within its own domain, but often we find a transformation to a new medium as well.
Therefore art can be seen as a self-referential system in which the copies and quotations are the modules which allow for re-contextualizations 

In order to allow modularization it is important to be transparent, open, critical and open to changes in order to gain a concept of better understanding.

\section{Refactoring software}

If we perform a quantitative analysis on the Linux kernel, which is biggest open source project, we can see
that a high percentage of changes are not in the territory of writing new features or fixing bugs, but often 
contain a concept of refactoring - changing and re-arranging existing structures.

This is indeed the art in programming as this is not pre-determined by algorithm and there is no
single best solution to this problem.

\section{Refactoring art}

Although the concept of refactoring originates in software engineering we have shown that this concept is also
present in art but often more in a meta context.
We can therefore ask ourselves how the transformation of this meta context of refactoring to an art artifact itself
could be achieved.

Yet a naïve approach of just doing a comparison of an artifact which has been exposed to refactoring and another one
not is not fruitful as the concept of refactoring is that the same input should also produce the same output.
Yet the interface of what the in- and output should be can be subject to change in refactoring.

If we expose somebody to Max MSP or to Microsoft Power Point we expect the artifact to be something different, although
both programs are Turing complete.

\subsection{Iannis Xenakis: Formalized Music}

As this paper is written on a music academy we want to inspect this principle on the domain of Iannis Xenakis.
One of his goal was to build a unified language for music through which every aspect can be transformed [towards a metamusic].
Of course we can simply argue that this is doomed to fail as the meta language experiments of the 60s have shown us [?], yet we allow ourselves to take a look at what this principle allows us to do and how the principle of refactoring is applied here.


\section{Refactoring both}

Now we can take a look where both things merge, at the SuperCollider source code of the tuning implementations?


\end{document}