\documentclass[10pt,twocolumn,letterpaper]{article}

\usepackage[scaled]{helvet}
\usepackage[T1]{fontenc}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{epsfig}
\usepackage{tikz} 
\usepackage{graphicx}
\usepackage{stackengine}
\usepackage{times}
\usepackage{url}
\usepackage[backend=bibtex]{biblatex}

%\usepackage[pagebackref=true,breaklinks=true,colorlinks,bookmarks=false,linkcolor=black,citecolor=black]{hyperref}
\usepackage{hyperref}

\def\httilde{\mbox{\tt\raisebox{-.5ex}{\symbol{126}}}}

\newcommand\todo[1]{\textcolor{red}{ToDo: #1}}
\newcommand\note[1]{\textcolor{red}{Note: #1}}

\newcommand\email[1]{\small{\href{mailto:#1}{\color{black}{\nolinkurl{#1}}}}}

% Pages are numbered in submission mode, and unnumbered in camera-ready
\begin{document}

%%%%%%%%% TITLE
\title{Refactoring as epistemic and artistic practice}

\author{Dennis Scheiba\\
\email{dennis.scheiba@rsh-duesseldorf.de}\\
Robert Schumann Hochschule Düsseldorf - Institut für Musik und Medien\\
}
\maketitle

%%%%%%%%% ABSTRACT
\begin{abstract}
\vspace{-1em}
Refactoring is a crucial practice in software development, yet it is difficult to a precise goal to this process.
One could say that refactoring is re-evaluation and modification of existing modularization in the context of what the status quo is 
and what this status quo could be in the future.

Revisiting the work of oneself or others is not just important in software development but also within the art domain.
In this paper we want to explore how such a practice could be enforced to better understand how both domains handle with
common problems and how each other domain could adapt and improve from the other.
\end{abstract}

%%%%%%%%% BODY TEXT
\vspace{-1em}

\section{Refactoring and modularization} \label{what}

There is no singleton purpose of refactoring and although its purpose is arguably existing and much important
it is difficult to give a precise definition.
The struggle between intuitively, generalization and complexity is where refactoring lives.
Attached to this is also the trade-off between opening possibilities which always at the same time closes
other possibilities also.

A dependency for refactoring is the modularization into distinctive sub-parts, working a as a reference
which can adapt the environment in which it is used.
Yet we must discuss if modularization actually exists as abstraction itself is doubtful as well.

\subsection{Modularization}

Separating the terms software and art is highly doubtful and should not be made easily.
For the sake of simplicity we will nonetheless allow us to work with stereotypes here.

\subsubsection*{In Software}

Somehow there is a common conception of what a \textit{good} written software is and what is not.
This \textit{quality} can be evaluated on multiple categories such as

\begin{itemize}
    \item Bugs
    \item Features
    \item Usability
    \item Catholicity
    \item License
\end{itemize}

of which some categories can be linearly independent or strictly co-relating with each other.

There are even projects like \textit{SonarQube} which provide a formalized way of evaluating code based on some
parameters mentioned above.

Modularization in software allows for the restructuring of a given program, changing how the abstraction and
modularization of existing code is organized and programmed and therefore can hopefully yield better
results in the metrics mentioned above.
Common techniques for these things are design principles, paradigms or techniques.

Modularization in software is crucial when we regard topics such as Turing completeness which allows us
to classify programs if they can calculate any given program or not.
This means that all programs which are Turing complete are interchangeable we still rely on abstraction to
tame the possibilities.
This selection between is already art in itself.

\subsubsection*{In Art}

Modularization in art is maybe not as obvious as in software engineering, although it is present all the time.
As social beings we can not escape exposure to the culture around us, therefore all our creations
are simply just reactions to the input we have received.
This becomes the most obvious if we implement a reference to something else or make a copy of something existing.
Therefore art is in itself a self-referential system in which the copies and quotations are the modules.

The question now is if we can interchange the metrics between good software and good \textit{art}, allowing
us to quantize an artifact under the premise of certain metrics which is something the art-culture is often
afraid of doing but the pragmatism of software engineering requires it.

\subsection{Refactoring in software}

If we perform a quantitative analysis on the Linux kernel, which is biggest open source project, we can see
that a high percentage of changes are not in the territory of writing new features or fixing bugs, but often 
contain a concept of refactoring - changing and re-arranging existing structures.

This is indeed the art in programming as this is not pre-determined by algorithm and there is no
single best solution to this problem.

\section{Refactoring art}

Although the concept of refactoring originates in software engineering we have shown that this concept is also
present in art but often more in a meta context.
We can therefore ask ourselves how the transformation of this meta context of refactoring to an art artifact itself
could be achieved.

Yet a naïve approach of just doing a comparison of an artifact which has been exposed to refactoring and another one
not is not fruitful as the concept of refactoring is that the same input should also produce the same output.
Yet the interface of what the in- and output should be can be subject to change in refactoring.

If we expose somebody to Max MSP or to Microsoft Power Point we expect the artifact to be something different, although
both programs are Turing complete.

\subsection{Refactoring sound}

\subsection{Refactoring light}


\end{document}