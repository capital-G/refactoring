\documentclass[10pt,twocolumn,letterpaper]{article}

\usepackage[scaled]{helvet}
\usepackage[T1]{fontenc}
\usepackage{geometry}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{epsfig}
\usepackage{tikz} 
\usepackage{graphicx}
\usepackage{stackengine}
\usepackage{times}
\usepackage{url}

%\usepackage[pagebackref=true,breaklinks=true,colorlinks,bookmarks=false,linkcolor=black,citecolor=black]{hyperref}
\usepackage{hyperref}

\def\httilde{\mbox{\tt\raisebox{-.5ex}{\symbol{126}}}}

\newcommand\todo[1]{\textcolor{red}{ToDo: #1}}
\newcommand\note[1]{\textcolor{red}{Note: #1}}

\newcommand\email[1]{\small{\href{mailto:#1}{\color{black}{\nolinkurl{#1}}}}}

% Pages are numbered in submission mode, and unnumbered in camera-ready
\begin{document}

%%%%%%%%% TITLE
\title{Refactoring as epistemic and artistic practice}

\author{Dennis Scheiba\\
\email{dennis.scheiba@rsh-duesseldorf.de}\\
Robert Schumann Hochschule Düsseldorf - Institut für Musik und Medien\\
}
\maketitle

\begin{abstract}

\begin{quote}
There is no singleton purpose of refactoring and although its purpose is arguably important and performed everyday it is difficult to give a precise definition of the necessities for such a process.
The struggle between intuition, generalization, simplification and complexity is where refactoring resides.
Attached to this method is always the evaluation of a trade-off, between opening possibilities which at the same time makes other possibilities impossible.

Revisiting the work of oneself or others is not just important in software development but also within the context of art and science.
In this paper we want to explore how the practice of refactoring can be transformed to other domains and inspecting implementations, implication and practices which could be adopt and transformed among each domain.
\end{quote}
\end{abstract}

\vspace{-1em}

\section{Refactoring and modularization} \label{what}

Refactoring is a crucial and daily practice in software development, yet it is difficult to define a precise goal to this process.
One could argue that refactoring is a re-evaluation and modification of existing modularization in the context of what the status quo is and projecting what this status quo could and should be in the future.

The proclaimed modularization should allow us to separate an existing complex subject into distinctive yet not fully independent sub discretizations which then can be re-adapted on a per-context basis.
Mathematics, which is often labeled as a \textit{auxillary science}, has its goal to form such universal statements which can be re-adapted in various contexts.
This should be motivation enough to stay in this transformation area which allows us to change the foundations of our believes and allows us to not solve complexity but allows to inspect complexity within complexity itself.
Therefore we can see refactoring as an epistemic gesture.

Yet we must discuss if modularization actually exists as well as abstraction itself which should be doubted at first as well. \cite{Teil_Latour_1995}.

\subsection{Refactoring in Software}

There seems to be a common conception of what a \textit{good} written software is and what is not.
This \textit{quality} can be evaluated on multiple categories, but not limited to, such as

\begin{itemize}
    \itemsep0em
    \item Number of Bugs
    \item Features
    \item Usability
    \item Catholicity
    \item License
\end{itemize}

Yet it is important to comprehend that each of these metrics are rarely independent of each other.
An increase of features is likely to also increase the number of bugs as it introduces more and more edge cases which combinations can lead to bugs.
Projects like \textit{SonarQube} gives us the promise to quantify the quality of such source code based on certain criteria.
Yet we ask ourselves why such a Software is limited to the domain of programming source code and not beyond other domains which allow for re-transformation of their field, which means refactoring.
There are also certainly bugs which can not be observed on such a low level of analysis as the infamous quote
\begin{quote}
    is this a bug or a feature?
\end{quote}
demonstrates.
The classification and notion of what an error is and what is not therefore relies only on an implicit context which frictions can be shown when made explicit.

This distinction between malfunction and function is not limited to the domain of software as demonstrated by the quote
\begin{quote}
    % harpe kerkeling?
    is this art or rubbish
\end{quote}
,which probably finds it motivation by the infamous \textit{Fettecke} by Joseph Beuys, and therefore also makes it dependent of the embedded context.
An obvious domain of art which plays and enables to re-contextualize errors is glitch art \cite{Schubert_2019}.

[note that there are neural networks which evaluate aesthetic characteristics but not on a hard rule set?]

\subsection{Modularization}

Modularization in software allows an isolation, encapsulation and restructuring of a given complex and over the years certain patterns emerged in which software is build.
One of the most crucial things of modularization is a common API (Application Programming Interface) which allows the communication between.
Yet the construction of such an API is tied to the concepts of the domain itself but also allows to go beyond it.
Do we talk to everyone who can talk (duck typing) or do we only talk to a certain kind of entities (static typing)?
Common techniques are called design principles, paradigms or techniques, yet rarely they reflect on their ideological implications.

By reaching out we allow ourselves to re-contextualize the domain in a new context which offers, speaking in neo-liberalism terms, a win-win opportunity for both parties.
This allows for justification among society and ourselves what we are doing, providing a leap forward and gaining a new perspective to our field of interest and also to test our assumptions in a new domain.
% use turing completeness as a foundation here?

Although we yet omitted one crucial statement which is the foundation upon all modularization and transformation, the common ground of turing completeness which.
Yet it is false to assume that this allows us to do anything at all time - we do not use Power Point as a ? [note that powerpoint is indeed turing complete] and don't use this for that simply because the intentions of each tool are aimed at a different purpose  - while they all rely on a coordination of voltages in a circuit based upon its environment, art has the same universal language of communication as it tries to evoke a resonance within a biological circuit with the means of sensorial evaluation.

This means that all programs which are Turing complete are interchangeable but in order to build complex programs we need to tame the possibilities.
By deciding what is and what is not possible within our program we allow the program to exist [what about kernels?], albeit this reduction of possibilities can be achieved on different levels of operation.

This is often seen in the domain of arts as well as the segregation of fine arts, music, media art and science is still often separated at institutes.

Also the human as a social being can not escape exposure to its culture, therefore all creations could be seen as reactions to the input we have received.
The most obvious way of this mechanic is quotation or sampling which allows for a transformation and re-contextualization within its own domain, but often we find a transformation to a new medium as well.
Therefore art can be seen as a self-referential system in which the copies and quotations are the modules which allow for re-contextualizations 

In order to allow modularization it is important to be transparent, open, critical and open to changes in order to gain a concept of better understanding.

\cite{bratton_stack_2015}

\subsection{Modularization in science}

\section{Refactoring errors}

\subsection{Refactoring a black box}

Neural networks.

\subsection{Rhizom}

Software is not written and accessed from top to bottom but it works like a rhizom.

\section{Refactoring software}

If we perform a quantitative analysis on the Linux kernel, which is biggest open source project, we can see
that a high percentage of changes are not in the territory of writing new features or fixing bugs, but often 
contain a concept of refactoring - changing and re-arranging existing structures.

This is indeed the art in programming as this is not pre-determined by algorithm and there is no
single best solution to this problem.

\section{Refactoring art}

\cite{Schubert_2019}.

Although the concept of refactoring originates in software engineering we have shown that this concept is also
present in art but often more in a meta context.
We can therefore ask ourselves how the transformation of this meta context of refactoring to an art artifact itself
could be achieved.

Yet a naïve approach of just doing a comparison of an artifact which has been exposed to refactoring and another one
not is not fruitful as the concept of refactoring is that the same input should also produce the same output.
Yet the interface of what the in- and output should be can be subject to change in refactoring.

If we expose somebody to Max MSP or to Microsoft Power Point we expect the artifact to be something different, although
both programs are Turing complete.

\subsection{Iannis Xenakis: Formalized Music}

As this paper is written on a music academy we want to inspect this principle on the domain of Iannis Xenakis. \cite{Xenakis_1992}.
One of his goal was to build a unified language for music through which every aspect can be transformed [towards a metamusic].
Of course we can simply argue that this is doomed to fail as the meta language experiments of the 60s have shown us [?], yet we allow ourselves to take a look at what this principle allows us to do and how the principle of refactoring is applied here.


\section{Refactoring both}

Now we can take a look where both things merge, at the SuperCollider source code of the tuning implementations?

\bibliographystyle{alpha}
\bibliography{references}

\end{document}